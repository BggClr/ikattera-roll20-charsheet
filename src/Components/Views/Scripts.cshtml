@model string

<rolltemplate class="sheet-rolltemplate-attack">
	<div class="sheet-container">
	  <div class="sheet-header">
		{{#title}}<div class="sheet-title">{{title}}</div>{{/title}}
		{{#subtitle}}<div class="sheet-subtitle">{{subtitle}}</div>{{/subtitle}}
	  </div>
	  <div class="sheet-content">
		{{#allprops() total desc title subtitle}}
			<div class="sheet-key">{{key}}</div>
			<div class="sheet-value">{{value}}</div>
		{{/allprops() total desc title subtitle}}
		{{#computed::total}}
			<div class="sheet-key">Итого</div>
			<div class="sheet-value">{{computed::total}}</div>
		{{/computed::total}}
		{{#desc}}<div class="sheet-desc">{{desc}}</div>{{/desc}}
	  </div>
	</div>
</rolltemplate>

<rolltemplate class="sheet-rolltemplate-check">
	<div class="sheet-container">
	  <div class="sheet-header">
		{{#title}}<div class="sheet-title">{{title}}</div>{{/title}}
		{{#subtitle}}<div class="sheet-subtitle">{{subtitle}}</div>{{/subtitle}}
	  </div>
	  <div class="sheet-content">
		{{#allprops() desc title subtitle}}
			<div class="sheet-key">{{key}}</div>
			<div class="sheet-value">{{value}}</div>
		{{/allprops() desc title subtitle}}
		{{#desc}}<div class="sheet-desc">{{desc}}</div>{{/desc}}
	  </div>
	</div>
</rolltemplate>

<script type="text/worker">
	const CharsheetData = JSON.parse('@Html.Raw(Model)');
	const FeaturesList = ['attributes', 'skills', 'weapons'];
	const buttonList = ['character', 'attributes', 'skills', 'weapons', 'combat'];

	Array.prototype.distinct = function() {
		return this.filter((item, pos) => this.indexOf(item) === pos)
    };

	function findFeature(featureName) {
		return FeaturesList
        	.reduce((agg, key) => [...agg, ...CharsheetData[key]], [])
        	.filter(f => f.name == featureName)[0];
	}

	async function rollDice(dice, featureName, altKey, title) {
		getAttrs(getValuesListForCalculate(), async values => {
			const feature = findFeature(featureName);
			let modifiers = [
				featureName,
				`${featureName}_mod`
			];

			if (feature && feature.depends_on) {
				const greatestFeature = feature.depends_on
					.map(p => ({feature: p, value: (parseInt(values[p]) || 0) + (parseInt(values[`${p}_mod`]) || 0)}))
					.sort((a, b) => b.value - a.value)[0].feature;
				modifiers = [...modifiers, greatestFeature, `${greatestFeature}_mod`];
			}
			const rollResultModifiers = modifiers.map(p => `@@{${p}}`).join(' + ');
			const rollModifier = !!altKey ? '/w gm': '';

			const roll = `${rollModifier} &{template:check} {{title=@@{character_name}}} {{subtitle=${feature.title} ${title}}} {{Результат=[[${dice} + ${rollResultModifiers}]]}}`;
			const results = await startRoll(roll);
			finishRoll(results.rollId);
		});
	}

		function getDamageTypeTitle(name) {
    		const damageType =  CharsheetData.damage_types.filter(p => p.name == name)[0];
    		return (damageType && damageType.title) || name;
    	}

    	function getDamageRoll(weaponDamageRollDataItem) {
    		const dices = weaponDamageRollDataItem.dices;
    		const attributeBonuses = weaponDamageRollDataItem.attributeBonuses.map(p => `@@{${p}}`);
    		const valueBonuses = weaponDamageRollDataItem.valueBonuses;

    		return dices.concat(attributeBonuses).concat(valueBonuses).join(' + ');
    	}

    	async function rollWeaponDice(dice, weaponName, altKey, title) {
    		const rollModifier = !!altKey ? '/w gm': '';
    		const weaponPartAttributes = ['dice_type', 'damage_type', 'damage_attribute_bonus', 'damage_value_bonus']
        	getSectionIDs(`repeating_${weaponName}`, async weaponDamageIds => {
        		const parts = weaponDamageIds.reduce((agg, id) => [...agg, ...weaponPartAttributes.map(attr => `repeating_${weaponName}_${id}_${attr}`)], []);
        		const weaponAttributes = [
                    `${weaponName}_name`,
                    `${weaponName}_type`,
                    `${weaponName}_attack_attribute_bonus`,
                    `${weaponName}_attack_value_bonus`,
                    ...parts
                ];

                getAttrs(getValuesListForCalculate(weaponAttributes), async values => {
                    const attackRollModifiers = [
        					`${weaponName}_type`,
        					`${weaponName}_attack_attribute_bonus`
        				]
                        .filter(key => values[key] != null)
                        .reduce((agg, key) => [...agg, values[key], `${values[key]}_mod`], [])
                        .filter(key => values[key] != null)
                        .concat(values[`${weaponName}_attack_value_bonus`] != null ? [`${weaponName}_attack_value_bonus`] : [])
                        .map(p => `@@{${p}}`)

        			const weaponDamageRollData = weaponDamageIds
        				.map(id => ({id, damageType: `repeating_${weaponName}_${id}_damage_type`}))
        				.reduce((agg, p) => {
        					const dice = values[`repeating_${weaponName}_${p.id}_dice_type`];
        					const damageAttributeBonus = values[`repeating_${weaponName}_${p.id}_damage_attribute_bonus`];
        					const damageValueBonus = values[`repeating_${weaponName}_${p.id}_damage_value_bonus`];

        					if (!values[p.damageType]) {
        						return agg;
        					}

        					if (!!agg[values[p.damageType]]) {
        						return {
        							...agg,
        							[values[p.damageType]]: {
        								dices: [...agg[values[p.damageType]].dices, dice].filter(p => !!p),
        								attributeBonuses: [...agg[values[p.damageType]].attributeBonuses, damageAttributeBonus, `${damageAttributeBonus}_mod`].filter(p => !!p && !!values[p]),
        								valueBonuses: [...agg[values[p.damageType]].valueBonuses, damageValueBonus].filter(p => !!p)
        							}
        						};
        					}
        					return {
        						...agg,
        						[values[p.damageType]]: {
        							dices: [dice].filter(p => !!p),
        							attributeBonuses: [damageAttributeBonus, `${damageAttributeBonus}_mod`].filter(p => !!p && !!values[p]),
        							valueBonuses: [damageValueBonus].filter(p => !!p)
        						}
        					};
        				}, {});

        			const damageRollGroups = Object.keys(weaponDamageRollData)
        				.map(key => `{{${getDamageTypeTitle(key)}=[[${getDamageRoll(weaponDamageRollData[key])}]]}}`)

        			const attackRoll = [dice]
        				.concat(attackRollModifiers)
        				.join(' + ');

                    const roll = `${rollModifier} &{template:attack} {{subtitle=${title}}} {{title=@@{character_name}}} {{weapon=@@{${weaponName}_name}}} {{Попадание=[[${attackRoll}]]}} ${damageRollGroups} {{total=[[0]]}}`;
                    const results = await startRoll(roll);
                    const total = Object.keys(weaponDamageRollData).reduce((agg, key) => agg + results.results[getDamageTypeTitle(key)].result, 0);

                    finishRoll(results.rollId, {
                        total
                    });
                });
        	});
    	}

	function getCharsheetFeatures() {
		return FeaturesList.reduce((agg, key) => [...agg, ...CharsheetData[key]], []);
	}

	function getFeaturesValuesByType(data, level) {
		if (!data || !data.level_bonus) {
        	return 0;
        }

        return Object
        	.keys(data.level_bonus)
        	.filter(l => parseInt(l) > 0 && parseInt(l) <= level)
        	.reduce((agg, key) => Object.keys(agg).concat(Object.keys(data.level_bonus[key]))
        		    .distinct()
        			.reduce((levelAgg, levelKey) => ({...levelAgg, [levelKey]: (agg[levelKey] || 0) + (data.level_bonus[key][levelKey] || 0)}), {})
        	, {});
	}

	function getFeaturesValues(values, level) {
		level = level || values.level || 0;
    	const race = CharsheetData.races.find(r => r.name === values.race);
    	const characterClass = CharsheetData.classes.find(r => r.name === values.class);
    	const kind = !!race ? (race.kinds && race.kinds.find(k => k.name === values.kind)) : null;
    	const subclass = !!characterClass ? (characterClass.subclasses && characterClass.subclasses.find(k => k.name === values.subclass)) : null;

		const featureChangesByType = [CharsheetData, race, kind, characterClass, subclass].map(data => getFeaturesValuesByType(data, level));
		const keys = featureChangesByType
			.map(p => Object.keys(p))
			.reduce((agg, keys) => [...agg, ...keys], [])
			.distinct();

		return keys
			.reduce((agg, key) => ({...agg, [key]: featureChangesByType.reduce((featureValueAgg, features) => featureValueAgg + (features[key] || 0), 0) }), {})
	}

	function calculateFeatures(values, oldValues, level) {
		const newFeatures = getFeaturesValues(values, level);
		const oldFeatures = !!oldValues ? getFeaturesValues(oldValues, level) : {};
		const charsheetFeatures = getCharsheetFeatures();

		const pickedFeatures = 	FeaturesList
            .map(key => ({name: `${key}_free`, value: CharsheetData[key].reduce((agg, p) => (agg + (!!values[p.name] ? parseInt(values[p.name]) - (!!oldValues ? (oldFeatures[p.name] || 0) : (newFeatures[p.name] || 0)) : 0)), 0)}))
            .reduce((agg, f) => ({...agg, [f.name]: f.value}), {});

		const featuresDelta = Object.keys(newFeatures)
			.concat(Object.keys(oldFeatures))
			.concat(Object.keys(pickedFeatures))
			.distinct()
			.reduce((agg, key) => ({
				...agg,
				[key]: charsheetFeatures.filter(p => p.name === key).length
					? (newFeatures[key] || 0) - (oldFeatures[key] || 0)
					: (newFeatures[key] || 0) - (pickedFeatures[key] || 0)
			}), {});

		return featuresDelta;
	}

	function getValuesListForCalculate(attrs) {
		return FeaturesList
			.map(key => CharsheetData[key].map(f => f.name).reduce((agg, f) => [...agg, f, `${f}_mod`], []))
			.reduce((agg, f) => [...agg, ...f], [...FeaturesList.map(f => `${f}_free`),...(!!attrs ? attrs : []), 'level', 'race', 'kind', 'class', 'subclass', 'hp_base', 'hp_mod', 'hp_max', 'stamina_base', 'stamina_mod', 'stamina_max']);
	}

	function getNotificationClass(value) {
		if (!value) {
			return 'bg-secondary';
		}
		return value > 0 ? 'bg-success' : 'bg-danger';
	}

	function applyTabStyles() {
		getAttrs(FeaturesList.map(f => `${f}_free`), values => {
			FeaturesList.forEach(f => {
				$20(`[name="attr_${f}_free"]`)
                    .removeClass('bg-secondary bg-success bg-danger')
                    .addClass(getNotificationClass(values[`${f}_free`]));
			});
		});
	}

	function init() {
		getAttrs(getValuesListForCalculate(['hp', 'stamina']), values => {
        	var featuresDelta = calculateFeatures(values, null, values.level || CharsheetData.level);

			const features = getCharsheetFeatures()
        		.reduce((agg, feature) => ({...agg, [feature.name]: feature.value + (featuresDelta[feature.name] || 0), [`${feature.name}_mod`]: 0}), {});

        	const valueFeatures = ['hp_base', 'hp_mod', 'hp_max', 'hp', 'stamina_base', 'stamina_mod', 'stamina_max', 'stamina']
        		.filter(key => featuresDelta[key] != null)
        		.reduce((agg, key) => ({...agg, [key]: featuresDelta[key]}), {});

        	const defaultFeatures = {...features, ...valueFeatures};

			const featuresToSet = Object.keys(defaultFeatures)
				.filter(key => values[key] == null || values[key] === '')
				.reduce((agg, key) => ({...agg, [key]: defaultFeatures[key]}), {});

			const hpMax = (parseInt(featuresToSet.hp_base || values.hp_base) || 0)
                + (parseInt(featuresToSet.attribute_body || values.attribute_body) || 0) * 2
                + (parseInt(featuresToSet.attribute_body_mod || values.attribute_body_mod) || 0) * 2
                + (parseInt(values.hp_mod) || 0);
            const staminaMax = (parseInt(featuresToSet.stamina_base || values.stamina_base) || 0)
                + (parseInt(values.stamina_mod) || 0);

			const attrs = FeaturesList
				.reduce((agg, key) => {
					if (!featuresDelta[`${key}_free`]) {
						return agg;
					}
					return {
						...agg,
						[`${key}_free`]: featuresDelta[`${key}_free`]
					};
				}, {
					...featuresToSet,
					level: values.level || CharsheetData.level,
					hp_max: hpMax,
					stamina_max: staminaMax,
					hp: values.hp || hpMax,
					stamina: values.stamina || staminaMax
				});

			$20('.js-hp').removeClass([...Array(100).keys()].map(i => `width-${i+1}`).join(' ')).addClass(`width-${Math.min(100, Math.floor(100 * (values.hp || hpMax) / hpMax))}`);
			$20('.js-stamina').removeClass([...Array(100).keys()].map(i => `width-${i+1}`).join(' ')).addClass(`width-${Math.min(100, Math.floor(100 * (values.stamina || staminaMax) / staminaMax))}`);

			setAttrs(attrs, {silent: true});
			applyTabStyles();
		});
	}

	function applyFeatureChanges(values, oldValues, level) {
		const featuresDelta = calculateFeatures(values, oldValues, level || values.level);
		const charsheetFeatures = getCharsheetFeatures().map(f => f.name).concat(['hp_base', 'hp_mod', 'hp', 'stamina_base', 'stamina_mod', 'stamina']);

		const featuresFree = FeaturesList
			.filter(key => featuresDelta[`${key}_free`] != null)
			.reduce((agg, key) => ({...agg, [`${key}_free`]: featuresDelta[`${key}_free`]}), {})

		const attrs = Object
			.keys(featuresDelta)
			.filter(key => charsheetFeatures.indexOf(key) >= 0)
			.reduce((agg, key) => ({...agg, [key]: (parseInt(values[key]) || 0) + featuresDelta[key]}), featuresFree)

		setAttrs(attrs, {silent: true});
		getAttrs(['hp_base', 'hp_mod', 'attribute_body', 'attribute_body_mod', 'stamina_base', 'stamina_mod', 'hp', 'stamina'], updatedValues => {
	        const hpMax = (parseInt(updatedValues.hp_base) || 0)
	            + (parseInt(updatedValues.attribute_body) || 0) * 2
	            + (parseInt(updatedValues.attribute_body_mod) || 0) * 2
	            + (parseInt(updatedValues.hp_mod) || 0);
	        const staminaMax = (parseInt(updatedValues.stamina_base) || 0)
	            + (parseInt(updatedValues.stamina_mod) || 0);
	        setAttrs({
        		hp_max: hpMax,
        		stamina_max: staminaMax,
        		hp: updatedValues.hp || hpMax,
        		stamina: updatedValues.stamina || staminaMax
	        });
	    });

		applyTabStyles();
	}

	function fillKinds(raceName) {
		const race = CharsheetData.races.filter(p => p.name == raceName)[0];
		if (race && race.kinds) {
			populateListOptions({
                elemSelector: '#form_kind',
                optionsArray: [
                    {label: 'Выберите вид', value: 'none', disabled: true, selected: true},
                    ...race.kinds.sort((a, b) => a.title.localeCompare(b.title)).map(k => ({label: k.title, value: k.name}))
                ]
            });
			$20('.js-group-kind').removeClass('hidden');
		} else {
        	$20('.js-group-kind').addClass('hidden');
		}
	}
	function fillSubClasses(className) {
		const characterClass = CharsheetData.classes.filter(p => p.name == className)[0];
		if (characterClass && characterClass.subclasses) {
			populateListOptions({
                elemSelector: '#form_subclass',
                optionsArray: [
                    {label: 'Выберите подкласс', value: 'none', disabled: true, selected: true},
                    ...characterClass.subclasses.sort((a, b) => a.title.localeCompare(b.title)).map(k => ({label: k.title, value: k.name}))
                ]
            });
			$20('.js-group-subclass').removeClass('hidden');
		} else {
        	$20('.js-group-subclass').addClass('hidden');
		}
	}

	on('sheet:opened', async function () {
		setAttrs({
			sheetTab: 'character'
		});
		getAttrs(['race', 'class', 'level'], function(values) {
			if (values.level < 3) {
				setAttrs({
					subclass: 'none'
				});
				$20('.js-group-subclass').addClass('disabled');
			}
			fillKinds(values.race);
			fillSubClasses(values.class)
		});
		init();
	});

	buttonList.forEach(button => {
    	on(`clicked:${button}`, function() {
    		$20('.nav-link').removeClass('active');
    		$20(`button[name='act_${button}']`).addClass('active');
    		setAttrs({
    			sheetTab: button
    		});
    	});
    });

	FeaturesList
		.reduce((agg, key) => [...agg, ...CharsheetData[key]], [])
		.forEach(feature => {
			on(`change:${feature.name}`, e => {
				if (e.sourceType === 'sheetworker') {
					return;
				}

				getAttrs(getValuesListForCalculate(), values => {
					const oldValues = e.previousValue && e.previousValue != e.newValue
        				? {...values, [feature.name]: e.previousValue}
        				: {...values, [feature.name]: 0};
					applyFeatureChanges(values, oldValues);
				});
			});
		});

	on('change:hp_max', e => {
		getAttrs(['hp_max', 'hp'], values => {
			$20('.js-hp').removeClass([...Array(100).keys()].map(i => `width-${i+1}`).join(' ')).addClass(`width-${Math.min(100, Math.floor(100 * values.hp  / values.hp_max))}`);
		});
	});
	on('change:hp', e => {
		getAttrs(['hp_max', 'hp'], values => {
			$20('.js-hp').removeClass([...Array(100).keys()].map(i => `width-${i+1}`).join(' ')).addClass(`width-${Math.min(100, Math.floor(100 * values.hp  / values.hp_max))}`);
		});
	});
	on('change:stamina_max', e => {
		getAttrs(['stamina_max', 'stamina'], values => {
			$20('.js-stamina').removeClass([...Array(100).keys()].map(i => `width-${i+1}`).join(' ')).addClass(`width-${Math.min(100, Math.floor(100 * values.stamina  / values.stamina_max))}`);
		});
	});
	on('change:stamina', e => {
		getAttrs(['stamina_max', 'stamina'], values => {
			$20('.js-stamina').removeClass([...Array(100).keys()].map(i => `width-${i+1}`).join(' ')).addClass(`width-${Math.min(100, Math.floor(100 * values.stamina  / values.stamina_max))}`);
		});
	});
	on('change:hp_mod', e => {
    	if (e.sourceType === 'sheetworker') {
    		return;
    	}
    	getAttrs(getValuesListForCalculate(), values => {
    		applyFeatureChanges(values, values);
    	});
    });
    on('change:stamina_mod', e => {
    	if (e.sourceType === 'sheetworker') {
    		return;
    	}
    	getAttrs(getValuesListForCalculate(), values => {
    		applyFeatureChanges(values, values);
    	});
    });
    on('change:attribute_body_mod', e => {
    	if (e.sourceType === 'sheetworker') {
    		return;
    	}
    	getAttrs(getValuesListForCalculate(), values => {
    		applyFeatureChanges(values, values);
    	});
    });

	on('change:level', e => {
		const currentLevel = parseInt(e.newValue);

		getAttrs(getValuesListForCalculate(), values => {
			const oldValues = e.previousValue && e.previousValue != e.newValue
        		? {...values, level: e.previousValue}
        		: {...values, level: 0};
			applyFeatureChanges(values, oldValues);
		});

		if (currentLevel < 3) {
			setAttrs({
				subclass: 'none'
			});
			$20('.js-group-subclass').addClass('disabled');
		} else {
			$20('.js-group-subclass').removeClass('disabled');
		}
	});

	on('change:race', e => {
		getAttrs(getValuesListForCalculate(), values => {
			setAttrs({ kind: 'none' }, { silent: true }, () => {
                const oldValues = e.previousValue && e.previousValue != e.newValue
                    ? {...values, race: e.previousValue, kind: values.kind}
                    : {...values, race: null, kind: null};
                applyFeatureChanges(values, oldValues);
            });
        });
        fillKinds(e.newValue);
	});

	on('change:class', e => {
		getAttrs(getValuesListForCalculate(), values => {
			setAttrs({ subclass: 'none' }, { silent: true }, () => {
                const oldValues = e.previousValue && e.previousValue != e.newValue
                    ? {...values, class: e.previousValue, subclass : values.subclass}
                    : {...values, class: null, subclass: null};
                applyFeatureChanges(values, oldValues);
            });
        });
        fillSubClasses(e.newValue);
	});

	on('change:kind', e => {
		if (e.sourceType === 'sheetworker') {
			return;
		}

		getAttrs(getValuesListForCalculate(), values => {
			const oldValues = e.previousValue && e.previousValue != e.newValue
				? {...values, kind: e.previousValue}
				: {...values, kind: 'none'};
			applyFeatureChanges(values, oldValues);
		});
	});

	$20('button.js-combat-weapon-edit').on('click', e => {
		const section = e.htmlAttributes['data-section'];
		$20(`.${section} .js-combat-weapon-edit`).removeClass('show');
		$20(`.${section} .combat-weapon-nav-rolls`).removeClass('show');
		$20(`.${section} .js-combat-weapon-complete-edit`).addClass('show');
		$20(`.${section} .js-combat-weapon-details `).addClass('show');
	});

	$20('button.js-combat-weapon-complete-edit').on('click', e => {
		const section = e.htmlAttributes['data-section'];
		$20(`.${section} .js-combat-weapon-edit`).addClass('show');
		$20(`.${section} .combat-weapon-nav-rolls`).addClass('show');
		$20(`.${section} .js-combat-weapon-complete-edit`).removeClass('show');
		$20(`.${section} .js-combat-weapon-details `).removeClass('show');
	});

	$20('button.js-weapon-roll').on('click', async e => {
		await rollWeaponDice('2d10', e.htmlAttributes['data-name'], e.altKey, 'Атака');
	});
	$20('button.js-weapon-roll-adv').on('click', async e => {
		await rollWeaponDice('3d10kh2', e.htmlAttributes['data-name'], e.altKey, 'Атака с преимуществом');
	});
	$20('button.js-weapon-roll-dis').on('click', async e => {
		await rollWeaponDice('3d10kl2', e.htmlAttributes['data-name'], e.altKey, 'Атака с помехой');
	});

	$20('button.js-roll').on('click', async e => {
		await rollDice('2d10', e.htmlAttributes['data-name'], e.altKey, '');
	});
	$20('button.js-roll-adv').on('click', async e => {
		await rollDice('3d10kh2', e.htmlAttributes['data-name'], e.altKey, 'с преимуществом');
	});
	$20('button.js-roll-dis').on('click', async e => {
		await rollDice('3d10kl2', e.htmlAttributes['data-name'], e.altKey, 'с помехой');
	});
</script>
